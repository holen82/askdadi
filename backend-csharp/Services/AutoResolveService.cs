using System.Text.RegularExpressions;
using DadiChatBot.Models;
using Microsoft.Extensions.Logging;

namespace DadiChatBot.Services;

public class AutoResolveService
{
    private readonly GitHubService _github;
    private readonly OpenAIService _openAI;
    private readonly ILogger<AutoResolveService> _logger;

    public AutoResolveService(
        GitHubService github,
        OpenAIService openAI,
        ILogger<AutoResolveService> logger)
    {
        _github = github;
        _openAI = openAI;
        _logger = logger;
    }

    public async Task<int> RunAutoResolveAsync(CancellationToken ct = default)
    {
        var issues = await _github.GetIssuesForAutoResolveAsync(ct);
        _logger.LogInformation("Found {Count} issue(s) to auto-resolve.", issues.Count);

        if (issues.Count == 0) return 0;

        List<SourceFile> sourceFiles;
        try
        {
            sourceFiles = await FetchSourceFilesAsync(ct);
            _logger.LogInformation("Fetched {Count} source file(s).", sourceFiles.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to fetch source files. Aborting auto-resolve.");
            return 0;
        }

        int processed = 0;
        foreach (var issue in issues)
        {
            try
            {
                await ProcessIssueAsync(issue, sourceFiles, ct);
                processed++;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to process issue #{Number}: {Title}", issue.Number, issue.Title);
            }
        }
        return processed;
    }

    private async Task ProcessIssueAsync(GitHubIssue issue, List<SourceFile> sourceFiles, CancellationToken ct)
    {
        _logger.LogInformation("Processing issue #{Number}: {Title}", issue.Number, issue.Title);

        // Step 1: Add autoresolve label first for idempotency
        await _github.AddLabelToIssueAsync(issue.Number, "autoresolve", ct);

        // Step 2: Generate implementation plan
        string plan;
        try
        {
            plan = await _openAI.GenerateImplementationPlanAsync(
                issue.Title,
                issue.Body ?? string.Empty,
                sourceFiles,
                ct);
        }
        catch (InvalidOperationException ex) when (ex.Message == "CONTEXT_LENGTH_EXCEEDED")
        {
            _logger.LogWarning("Context length exceeded for issue #{Number}. Retrying with reduced context.", issue.Number);
            var reduced = GetReducedFiles(sourceFiles);
            plan = await _openAI.GenerateImplementationPlanAsync(
                issue.Title,
                issue.Body ?? string.Empty,
                reduced,
                ct);
        }

        // Step 3: Post plan as comment
        var commentBody = $"## Auto-Resolution Plan\n\n{plan}\n\n---\n*Generated by DadiChatBot AutoResolve*";
        await _github.PostIssueCommentAsync(issue.Number, commentBody, ct);

        // Step 4: Generate code changes
        AiCodeChangesResponse codeChanges;
        try
        {
            codeChanges = await _openAI.GenerateCodeChangesAsync(
                issue.Title,
                issue.Body ?? string.Empty,
                plan,
                sourceFiles,
                ct);
        }
        catch (InvalidOperationException ex) when (ex.Message == "CONTEXT_LENGTH_EXCEEDED")
        {
            _logger.LogWarning("Context length exceeded for code gen on issue #{Number}. Retrying with reduced context.", issue.Number);
            var reduced = GetReducedFiles(sourceFiles);
            codeChanges = await _openAI.GenerateCodeChangesAsync(
                issue.Title,
                issue.Body ?? string.Empty,
                plan,
                reduced,
                ct);
        }

        if (codeChanges.FileChanges.Count == 0)
        {
            _logger.LogWarning("AI returned no file changes for issue #{Number}. Skipping PR creation.", issue.Number);
            return;
        }

        // Create branch
        var headSha = await _github.GetHeadShaAsync(ct);
        var branchName = BuildBranchName(issue);
        await _github.CreateBranchAsync(branchName, headSha, ct);

        // Commit each file
        foreach (var (filePath, content) in codeChanges.FileChanges)
        {
            try
            {
                var existingSha = await _github.GetFileShaAsync(filePath, branchName, ct);
                await _github.UpsertFileAsync(
                    filePath,
                    content,
                    $"Auto-resolve #{issue.Number}: update {filePath}",
                    branchName,
                    existingSha,
                    ct);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to commit file {FilePath} for issue #{Number}", filePath, issue.Number);
            }
        }

        // Create PR
        var prTitle = $"Auto-resolve: #{issue.Number} - {issue.Title}";
        var prBody = $"Closes #{issue.Number}\n\n{codeChanges.Summary}\n\n*Auto-generated by DadiChatBot AutoResolve*";
        var prUrl = await _github.CreatePullRequestAsync(prTitle, prBody, branchName, ct);
        _logger.LogInformation("Created PR for issue #{Number}: {Url}", issue.Number, prUrl);
    }

    private async Task<List<SourceFile>> FetchSourceFilesAsync(CancellationToken ct)
    {
        var tree = await _github.GetRepoTreeAsync(ct);
        var relevant = tree.Where(item => item.Type == "blob" && IsRelevantFile(item.Path)).ToList();

        var files = new List<SourceFile>();
        foreach (var item in relevant)
        {
            try
            {
                var content = await _github.GetBlobContentAsync(item.Sha, ct);
                files.Add(new SourceFile(item.Path, content));
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to fetch blob for {Path}", item.Path);
            }
        }
        return files;
    }

    private static bool IsRelevantFile(string path)
    {
        if (path.Contains("/bin/") || path.Contains("/obj/") ||
            path.Contains("node_modules/") || path.Contains("/dist/") ||
            path.Contains("/.vs/") || path.EndsWith(".css") || path.EndsWith(".d.ts"))
            return false;

        if (path.StartsWith("backend-csharp/", StringComparison.OrdinalIgnoreCase) &&
            (path.EndsWith(".cs") || path.EndsWith(".csproj")))
            return true;

        if (path.StartsWith("frontend/src/", StringComparison.OrdinalIgnoreCase) && path.EndsWith(".ts"))
            return true;

        if (path.Equals("frontend/index.html", StringComparison.OrdinalIgnoreCase))
            return true;

        return false;
    }

    private static List<SourceFile> GetReducedFiles(List<SourceFile> sourceFiles) =>
        sourceFiles
            .Where(f => f.Path.StartsWith("backend-csharp/Services/", StringComparison.OrdinalIgnoreCase)
                     || f.Path.StartsWith("backend-csharp/Functions/", StringComparison.OrdinalIgnoreCase))
            .ToList();

    private static string BuildBranchName(GitHubIssue issue)
    {
        var slug = Regex.Replace(issue.Title.ToLowerInvariant(), @"[^a-z0-9]+", "-").Trim('-');
        if (slug.Length > 40) slug = slug[..40].TrimEnd('-');
        return $"auto-resolve/issue-{issue.Number}-{slug}";
    }
}
